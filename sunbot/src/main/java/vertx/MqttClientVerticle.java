package vertx;

import java.util.Random;

import io.netty.handler.codec.mqtt.MqttConnectReturnCode;
import io.netty.handler.codec.mqtt.MqttQoS;
import io.vertx.core.AbstractVerticle;
import io.vertx.core.Promise;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.json.Json;
import io.vertx.mqtt.MqttClient;
import io.vertx.mqtt.MqttClientOptions;
import io.vertx.mqtt.impl.MqttClientImpl;
import types.MotorValue;
import types.SensorValue;

public class MqttClientVerticle extends AbstractVerticle {
	private static Boolean sync = new Boolean(true);
	private String classInstanceId;

	public void start(Promise<Void> promise) {
		classInstanceId = this.hashCode() + "";
		MqttClientOptions options = new MqttClientOptions();
		options.setAutoKeepAlive(true);
		options.setAutoGeneratedClientId(false);
		options.setClientId(classInstanceId);
		options.setConnectTimeout(5000);
		options.setCleanSession(true);
		options.setKeepAliveTimeSeconds(10000);
		options.setReconnectAttempts(10);
		options.setReconnectInterval(5000);
		options.setUsername("mqttbroker");
		options.setPassword("mqttbrokerpass");
		MqttClient mqttClient = new MqttClientImpl(vertx, options);

		mqttClient.publishHandler(messageReceivedHandler -> {
			MqttMessageFormat mqttMessageFormat = new MqttMessageFormat(classInstanceId, messageReceivedHandler);
			synchronized (sync) {
				System.out.println("------------------ Begin message received ------------------");
				System.out.println(Json.encodePrettily(mqttMessageFormat));
				System.out.println("------------------ End message received ------------------");
			}

		});

		Random randomTimeSeconds = new Random();
		mqttClient.connect(1885, "localhost", handler -> {
			if (handler.result().code() == MqttConnectReturnCode.CONNECTION_ACCEPTED) {
				mqttClient.subscribe(MQTTServerVerticle.TOPIC_INFO, MqttQoS.AT_LEAST_ONCE.value(), handlerSubscribe -> {
					if (handlerSubscribe.succeeded()) {
						System.out.println(
								classInstanceId + " subscribed to " + MQTTServerVerticle.TOPIC_INFO + " channel");

						vertx.setPeriodic(10000, handlerPeriodic -> {
							mqttClient.publish(MQTTServerVerticle.TOPIC_INFO,
									Buffer.buffer(classInstanceId + " says here I'm"), MqttQoS.AT_LEAST_ONCE, false,
									true);
						});

					} else {
						System.out.println(classInstanceId + " NOT subscribed to " + MQTTServerVerticle.TOPIC_INFO
								+ " channel " + handlerSubscribe.cause().toString());
					}
				});
				
				mqttClient.subscribe(MQTTServerVerticle.TOPIC_SENSOR, MqttQoS.AT_LEAST_ONCE.value(), handlerSubscribe -> {
					if (handlerSubscribe.succeeded()) {
						System.out.println(
								classInstanceId + " subscribed to " + MQTTServerVerticle.TOPIC_SENSOR + " channel");
						vertx.setPeriodic((7 + randomTimeSeconds.nextInt(5)) * 1000, handlerPeriodic -> {
							SensorValue sensor = new SensorValue((int)Math.round(Math.random()), 500, 8);

							mqttClient.publish(MQTTServerVerticle.TOPIC_SENSOR,
									Buffer.buffer(Json.encodePrettily(sensor)), MqttQoS.AT_LEAST_ONCE, false, true);
						});

					} else {
						System.out.println(classInstanceId + " NOT subscribed to " + MQTTServerVerticle.TOPIC_SENSOR
								+ " channel " + handlerSubscribe.cause().toString());
					}
				});
						
				mqttClient.subscribe(MQTTServerVerticle.TOPIC_MOTOR, MqttQoS.AT_LEAST_ONCE.value(), handlerSubscribe -> {
					if (handlerSubscribe.succeeded()) {
						System.out.println(
								classInstanceId + " subscribed to " + MQTTServerVerticle.TOPIC_MOTOR + " channel");
						vertx.setPeriodic((7 + randomTimeSeconds.nextInt(5)) * 1000, handlerPeriodic -> {
							MotorValue motor = new MotorValue((int)Math.round(Math.random()));

							mqttClient.publish(MQTTServerVerticle.TOPIC_MOTOR,
									Buffer.buffer(Json.encodePrettily(motor)), MqttQoS.AT_LEAST_ONCE, false, true);
						});

					} else {
						System.out.println(classInstanceId + " NOT subscribed to " + MQTTServerVerticle.TOPIC_MOTOR
								+ " channel " + handlerSubscribe.cause().toString());
					}
				});
			} else {
				System.out.println("Error: " + handler.result().code().toString());
			}
		});
	}

}
